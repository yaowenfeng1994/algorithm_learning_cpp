//
// Created by 姚文锋 on 2018/9/16.
//
//292. Nim游戏
#include "dp.h"
using namespace std;

bool dynamicProgramming::canWinNim(int n) {
/*这里做一个抽象，假设一推里面有n个石头，每次可以取 1-m 个石头。
显然，如果n=m+1，那么由于一次最多只能取m个，所以，无论先取者拿走多少个，
 后取者都能够一次拿走剩余的物品，后者取胜。这里我们就有一个想法了，假设这个石头推为 (m+1)的倍数，
 那么第一个人取k( 1 <= k <= m)个，只要第二个人取 (m+1-k)个石头，那么必定状态能回到最初的状态，
 m+1个。因为每个人都是很聪明的，取的石头的个数一定要对自己有利。那么，假设最初石头推不为 (m+1)的倍数。
 n=（m+1）r+s，那么第一个人只要取s个石头必定能获得胜利，反之，如果s == 0 ，那么第一个人必输。*/
    return (n % 4) == 0 ? false : true;
}
